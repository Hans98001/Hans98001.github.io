<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-atom.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="计算机网络 TCP&#x2F;IP TCP和UDP区别 TCP如何保证传输的可靠性？ UDP如何实现可靠传输？ 三次握手 TCP 为什么是三次握手，而不是两次或四次？ 原因一：避免历史连接，浪费资源 原因二：同步双方初始序列号   三次握手过程中如果最后一次握手失败会怎样处理？   TCP 四次挥手 为什么挥手需要四次？ 为什么 TIME_WAIT 等待的时间是 2MSL？ 为什么需要 TIME_WAIT">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://example.com/posts/e255a10a/index.html">
<meta property="og:site_name" content="May the Force be with you">
<meta property="og:description" content="计算机网络 TCP&#x2F;IP TCP和UDP区别 TCP如何保证传输的可靠性？ UDP如何实现可靠传输？ 三次握手 TCP 为什么是三次握手，而不是两次或四次？ 原因一：避免历史连接，浪费资源 原因二：同步双方初始序列号   三次握手过程中如果最后一次握手失败会怎样处理？   TCP 四次挥手 为什么挥手需要四次？ 为什么 TIME_WAIT 等待的时间是 2MSL？ 为什么需要 TIME_WAIT">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/posts/e255a10a/v2-4ddab99ec7f379dcefd209805643e76c_720w.jpg">
<meta property="og:image" content="http://example.com/posts/e255a10a/v2-4ddc4f09a9bcdd61a2df37b85889cec4_720w.jpg">
<meta property="og:image" content="http://example.com/posts/e255a10a/v2-4bac0a2a0e8a7b7dad4f8d2c7d6a865c_720w.jpg">
<meta property="og:image" content="http://example.com/posts/e255a10a/v2-a57f88fefee27a26639f915b476530d9_720w.jpg">
<meta property="og:image" content="http://example.com/posts/e255a10a/v2-a354cca7a7fad22c7e381783ce9018d3_720w.jpg">
<meta property="og:image" content="http://example.com/posts/e255a10a/image-20210519104612727.png">
<meta property="og:image" content="http://example.com/posts/e255a10a/image-20210519104657473.png">
<meta property="og:image" content="http://example.com/posts/e255a10a/image-20210519140456662.png">
<meta property="og:image" content="http://example.com/posts/e255a10a/v2-1cc37f757263f3cd58e917059cedc7b5_720w.jpg">
<meta property="og:image" content="http://example.com/posts/e255a10a/image-20210518170242567.png">
<meta property="og:image" content="http://example.com/posts/e255a10a/v2-ac0ecdad293a096d6b9402231af9f202_720w.jpg">
<meta property="og:image" content="http://example.com/posts/e255a10a/v2-60b3f27b9214aee5ca33ec648ab5ea60_720w.jpg">
<meta property="og:image" content="http://example.com/posts/e255a10a/v2-4c7d19df7e5964f1ee7a0a079ac30c51_720w.jpg">
<meta property="og:image" content="http://example.com/posts/e255a10a/v2-2085b747725cd09fb01334cd29774b6d_720w.jpg">
<meta property="og:image" content="http://example.com/posts/e255a10a/v2-5e3336e73d8b924381f347d0ebab1b71_720w.jpg">
<meta property="og:image" content="http://example.com/posts/e255a10a/v2-6a44dd001ef2ece18297121c90305861_720w.jpg">
<meta property="og:image" content="http://example.com/posts/e255a10a/1612195694-ROTKiX-%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5.png">
<meta property="og:image" content="http://example.com/posts/e255a10a/%E5%9B%BE%E8%A7%A3HTTP-1621563317262.jpg">
<meta property="og:image" content="http://example.com/posts/e255a10a/image-20210521140933387.png">
<meta property="og:image" content="http://example.com/posts/e255a10a/image-20210520185831982.png">
<meta property="og:image" content="http://example.com/posts/e255a10a/%E5%9B%BE%E8%A7%A3HTTP.jpg">
<meta property="og:image" content="http://example.com/posts/e255a10a/%E5%9B%BE%E8%A7%A3HTTP-1621511420167.jpg">
<meta property="article:published_time" content="2021-05-17T11:36:35.000Z">
<meta property="article:modified_time" content="2021-07-01T06:18:04.155Z">
<meta property="article:author" content="Tianyi Han">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/posts/e255a10a/v2-4ddab99ec7f379dcefd209805643e76c_720w.jpg">

<link rel="canonical" href="http://example.com/posts/e255a10a/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机网络 | May the Force be with you</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e46e4b7e8cd94928376c223cbe9da9f2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/Hans98001" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">May the Force be with you</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>时间轴</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/e255a10a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/upload/header.jpg">
      <meta itemprop="name" content="Tianyi Han">
      <meta itemprop="description" content="May the Force be with you">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="May the Force be with you">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-17 19:36:35" itemprop="dateCreated datePublished" datetime="2021-05-17T19:36:35+08:00">2021-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-01 14:18:04" itemprop="dateModified" datetime="2021-07-01T14:18:04+08:00">2021-07-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <ul>
<li>计算机网络<ul>
<li>TCP/IP<ul>
<li>TCP和UDP区别</li>
<li>TCP如何保证传输的可靠性？</li>
<li>UDP如何实现可靠传输？</li>
<li>三次握手<ul>
<li>TCP 为什么是三次握手，而不是两次或四次？<ul>
<li><em>原因一：避免历史连接，浪费资源</em></li>
<li><em>原因二：同步双方初始序列号</em></li>
</ul>
</li>
<li>三次握手过程中如果最后一次握手失败会怎样处理？</li>
</ul>
</li>
<li>TCP 四次挥手<ul>
<li>为什么挥手需要四次？</li>
<li>为什么 TIME_WAIT 等待的时间是 2MSL？</li>
<li>为什么需要 TIME_WAIT 状态？</li>
<li>TIME_WAIT 过多有什么危害？</li>
</ul>
</li>
</ul>
</li>
<li>HTTP/HTTPS<ul>
<li>工作流程</li>
<li>URI/URL</li>
<li>长连接/短连接</li>
<li>Session/Cookie/Token</li>
<li>代理</li>
<li>HTTP状态码</li>
<li>HTTP的不足</li>
<li>HTTPS加密</li>
<li>HTTPS通信机制</li>
<li>HTTPS的不足</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>

<p>mac地址无法被确定用在什么位置了，制造商、产品编号等层次对寻址没有起到作用。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><h3 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h3><p><strong>TCP是一个面向连接的、可靠的、基于字节流的传输层协议。</strong>而<strong>UDP是一个面向无连接的传输层协议。</strong></p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），增加了许多开销，如确认，流量控制，计时器以及连接管理等。协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等。</p>
<img src="/posts/e255a10a/v2-4ddab99ec7f379dcefd209805643e76c_720w.jpg" alt="img" style="zoom:80%;">

<h3 id="TCP如何保证传输的可靠性？"><a href="#TCP如何保证传输的可靠性？" class="headerlink" title="TCP如何保证传输的可靠性？"></a>TCP如何保证传输的可靠性？</h3><p>可靠性是指确保一个进程从其接收缓存中读出的数据流是无损坏，无间隔，非冗余和按序的数据流；即字节流与连接的另一方端系统发送出的字节流是完全相同的。需要解决的典型问题包括：</p>
<ul>
<li>干扰</li>
</ul>
<p>网络的干扰可能是因为硬件故障导致数据包受到破坏， 也有可能是网络波动导致数据包的某些 bit 位产生了变化。如下图，发送的 111 由于干扰变成了 101</p>
<p><img src="/posts/e255a10a/v2-4ddc4f09a9bcdd61a2df37b85889cec4_720w.jpg" alt="img"></p>
<p><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。主要作用是校验报文是否在传输过程中因为某些原因产生了变化（干扰），它并不能解决安全的问题。</p>
<ul>
<li>乱序&amp;冗余</li>
</ul>
<p>发送方连续先后发送两个数据包， 后发送的数据包可能先到达接收方，如果接收方按接收顺序处理数据包，这就会导致接收的数据包与发送的数据包不一致。</p>
<p>如下图，发送方顺序发送了 <code>A -&gt; B -&gt; C</code> 三个数据包， 然而接收方可能是以 <code>A -&gt; C -&gt; B</code> 这样的顺序接收的报文，很明显 B 和 C 两个个报文的顺序不符合期望，产生了乱序</p>
<p><img src="/posts/e255a10a/v2-4bac0a2a0e8a7b7dad4f8d2c7d6a865c_720w.jpg" alt="img"></p>
<p>发送方可能因为某些原因重复发送了同一个数据包，接收方要有能力处理这种冗余数据包。</p>
<p>比如发送方发送的一个数据包因为网络拥塞迟迟没有被接收方收到， 发送方认为产生了丢包就又重发了一次，最终接收方收到了两个同样的数据包，产生了数据冗余</p>
<p><img src="/posts/e255a10a/v2-a57f88fefee27a26639f915b476530d9_720w.jpg" alt="img"></p>
<p><strong>ARQ协议</strong>：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。停止等待协议、Go Back N协议，选择重传协议。</p>
<ul>
<li>丢包</li>
</ul>
<p>网络丢包是一个很常见的现象，造成的原因也多种多样，比较常见的有</p>
<ol>
<li>接收方由于缓存溢出，导致无法再处理到来的数据包了，直接丢弃从而造成丢包</li>
<li>网络拥塞导致数据包丢包</li>
<li>数据包被检测到损坏了，被接收方丢弃造成了丢包</li>
<li>……</li>
</ol>
<p>下图展示了这种情况，发送的数据 <code>CBA</code> 由于 <code>A</code> 产生了丢包，导致接收方只收到了 <code>CB</code></p>
<p><img src="/posts/e255a10a/v2-a354cca7a7fad22c7e381783ce9018d3_720w.jpg" alt="img"></p>
<p><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</p>
<p><img src="/posts/e255a10a/image-20210519104612727.png" alt="image-20210519104612727"></p>
<p><strong>拥塞控制：</strong> 网络的输入负荷超过网络传输能力。当网络拥塞时，减少数据的发送。</p>
<p><img src="/posts/e255a10a/image-20210519104657473.png" alt="image-20210519104657473"></p>
<ul>
<li><strong>慢启动：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li>
</ul>
<p><img src="/posts/e255a10a/image-20210519140456662.png" alt="image-20210519140456662"></p>
<ul>
<li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。</li>
</ul>
<p><img src="/posts/e255a10a/v2-1cc37f757263f3cd58e917059cedc7b5_720w.jpg" alt="img"></p>
<p><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>
<h3 id="UDP如何实现可靠传输？"><a href="#UDP如何实现可靠传输？" class="headerlink" title="UDP如何实现可靠传输？"></a>UDP如何实现可靠传输？</h3><p>UDP要想可靠，就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="/posts/e255a10a/image-20210518170242567.png" alt="image-20210518170242567"></p>
<p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<h4 id="TCP-为什么是三次握手，而不是两次或四次？"><a href="#TCP-为什么是三次握手，而不是两次或四次？" class="headerlink" title="TCP 为什么是三次握手，而不是两次或四次？"></a>TCP 为什么是三次握手，而不是两次或四次？</h4><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。三次握手才能保证双方具有接收和发送的能力。</p>
<p>接下来以两个方面分析三次握手的原因：</p>
<ul>
<li>三次握手才可以阻止重复历史连接的初始化（主要原因），避免资源浪费</li>
<li>三次握手才可以同步双方的初始序列号</li>
</ul>
<h5 id="原因一：避免历史连接，浪费资源"><a href="#原因一：避免历史连接，浪费资源" class="headerlink" title="原因一：避免历史连接，浪费资源"></a><em>原因一：避免历史连接，浪费资源</em></h5><p>我们来看看 RFC 793 指出的 TCP 连接使用三次握手的<strong>首要原因</strong>：</p>
<p>简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p>
<p>网络环境是错综复杂的，往往并不是如我们期望的一样，先发送的数据包，就先到达目标主机，反而它很骚，可能会由于网络拥堵等乱七八糟的原因，会使得旧的数据包，先到达目标主机，那么这种情况下 TCP 三次握手是如何避免的呢？</p>
<img src="/posts/e255a10a/v2-ac0ecdad293a096d6b9402231af9f202_720w.jpg" alt="img" style="zoom: 50%;">

<p>客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：</p>
<ul>
<li>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；</li>
<li>那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端；</li>
<li>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 <code>RST</code> 报文给服务端，表示中止这一次连接。</li>
</ul>
<p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：</p>
<ul>
<li>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 <code>RST</code> 报文，以此中止历史连接；</li>
<li>如果不是历史连接，则第三次发送的报文是 <code>ACK</code> 报文，通信双方就会成功建立连接；</li>
</ul>
<p>所以， TCP 使用三次握手建立连接的最主要原因是<strong>防止历史连接初始化了连接。</strong></p>
<p>如果只有「两次握手」，当客户端的 <code>SYN</code> 请求连接在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 <code>ACK</code> 确认信号，所以每收到一个 <code>SYN</code> 就只能先主动建立一个连接，这会造成什么情况呢？</p>
<p>如果客户端的 <code>SYN</code> 阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务器在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p>
<p>客户端发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达服务端。本来这是一个早已失效的报文段。但服务端收到此失效的连接请求报文段后，就误认为是客户端再次发出的一个新的连接请求。于是就向客户端发出确认报文段，同意建立连接。</p>
<p>假设不采用“三次握手”，那么只要服务端发出确认，新的连接就建立了。由于现在客户端并没有发出建立连接的请求，因此不会理睬服务端的确认，也不会向服务端发送数据。但服务端却以为新的运输连接已经建立，并一直等待客户端发来数据。这样，服务端的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，客户端不会向服务端的确认发出确认。服务端由于收不到确认，就知道客户端并没有要求建立连接。”</p>
<img src="/posts/e255a10a/v2-60b3f27b9214aee5ca33ec648ab5ea60_720w.jpg" alt="img" style="zoom:50%;">

<p>即两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</p>
<h5 id="原因二：同步双方初始序列号"><a href="#原因二：同步双方初始序列号" class="headerlink" title="原因二：同步双方初始序列号"></a><em>原因二：同步双方初始序列号</em></h5><p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的；</li>
</ul>
<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p>
<img src="/posts/e255a10a/v2-4c7d19df7e5964f1ee7a0a079ac30c51_720w.jpg" alt="img">

<p>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。</p>
<p>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<h4 id="三次握手过程中如果最后一次握手失败会怎样处理？"><a href="#三次握手过程中如果最后一次握手失败会怎样处理？" class="headerlink" title="三次握手过程中如果最后一次握手失败会怎样处理？"></a>三次握手过程中如果最后一次握手失败会怎样处理？</h4><p>当Client端收到Server的SYN+ACK应答后，其状态变为ESTABLISHED，并发送ACK包给Server；当客户端在 ESTABLISHED 状态下，开始发送数据包时，会携带上一个「ACK」的确认序号，所以哪怕客户端响应的「ACK」包丢了，服务端在收到这个数据包时，能够通过包内 ACK 的确认序号，正常进入 ESTABLISHED 状态。</p>
<p>如果此时ACK在网络中丢失，那么Server端该TCP连接的状态为SYN_RECV，等待超时后重新发送SYN+ACK包，以便Client重新发送ACK包。</p>
<p>Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5。</p>
<p>如果重发指定次数后，仍然未收到ACK应答，那么一段时间后，Server自动关闭这个连接。</p>
<p>如果客户端是恶意的，在发送「SYN」包后，并收到「SYN,ACK」后就不回复了，那么服务端此时处于一种半连接的状态，虽然服务端会通过 <code>tcp_synack_retries</code> 配置重试的次数，不会无限等待下去，但是这也是有一个时间周期的。</p>
<p>如果短时间内存在大量的这种恶意连接，对服务端来说压力就会很大，这就是所谓的 <strong>SYN FLOOD 攻击</strong>。DDos攻击的一种</p>
<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p>TCP 断开连接是通过<strong>四次挥手</strong>方式。双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</p>
<img src="/posts/e255a10a/v2-2085b747725cd09fb01334cd29774b6d_720w.jpg" alt="img" style="zoom:50%;">

<ul>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<p>每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p>
<p><strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p>
<h4 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h4><ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次。</p>
<h4 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h4><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 <code>TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</p>
<p>考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p>
<h4 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h4><p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p>
<p>需要 TIME-WAIT 状态，主要是两个原因：</p>
<ul>
<li>防止具有相同「四元组」的「旧」数据包被收到；</li>
<li>保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；</li>
</ul>
<p><em>原因一：防止旧连接的数据包</em></p>
<p>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？</p>
<img src="/posts/e255a10a/v2-5e3336e73d8b924381f347d0ebab1b71_720w.jpg" alt="img" style="zoom: 67%;">

<ul>
<li>如上图黄色框框服务端在关闭连接之前发送的 <code>SEQ = 301</code> 报文，被网络延迟了。</li>
<li>这时有相同端口的 TCP 连接被复用后，被延迟的 <code>SEQ = 301</code> 抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。</li>
</ul>
<p>所以，TCP 就设计出了这么一个机制，经过 <code>2MSL</code> 这个时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p>
<p><em>原因二：保证连接正确关闭</em></p>
<p>在 RFC 793 指出 TIME-WAIT 另一个重要的作用是：</p>
<p><strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p>
<p>假设 TIME-WAIT 没有等待时间或时间过短，断开连接会造成什么问题呢？</p>
<img src="/posts/e255a10a/v2-6a44dd001ef2ece18297121c90305861_720w.jpg" alt="img" style="zoom:80%;">

<ul>
<li>如上图红色框框客户端四次挥手的最后一个 <code>ACK</code> 报文如果在网络中被丢失了，此时如果客户端 <code>TIME-WAIT</code> 过短或没有，则就直接进入了 <code>CLOSE</code> 状态了，那么服务端则会一直处在 <code>LASE-ACK</code> 状态。</li>
<li>当客户端发起建立连接的 <code>SYN</code> 请求报文后，服务端会发送 <code>RST</code> 报文给客户端，连接建立的过程就会被终止。</li>
</ul>
<p>如果 TIME-WAIT 等待足够长的情况就会遇到两种情况：</p>
<ul>
<li>服务端正常收到四次挥手的最后一个 <code>ACK</code> 报文，则服务端正常关闭连接。</li>
<li>服务端没有收到四次挥手的最后一个 <code>ACK</code> 报文时，则会重发 <code>FIN</code> 关闭连接报文并等待新的 <code>ACK</code> 报文。</li>
</ul>
<p>所以客户端在 <code>TIME-WAIT</code> 状态等待 <code>2MSL</code> 时间后，就可以<strong>保证双方的连接都可以正常的关闭。</strong></p>
<h4 id="TIME-WAIT-过多有什么危害？"><a href="#TIME-WAIT-过多有什么危害？" class="headerlink" title="TIME_WAIT 过多有什么危害？"></a>TIME_WAIT 过多有什么危害？</h4><p>如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器方主动发起的断开请求。</p>
<p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ul>
<li>第一是内存资源占用；</li>
<li>第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口；</li>
</ul>
<p>第二个危害是端口资源的浪费</p>
<p><strong>如果发起连接一方的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。</strong></p>
<p>客户端受端口资源限制：</p>
<p>客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。</p>
<p>服务端受系统资源限制：</p>
<p>由于一个四元组表示 TCP 连接，理论上服务端可以建立很多连接，服务端确实只监听一个端口 但是会把连接扔给处理线程，所以理论上监听的端口可以继续监听。但是线程池处理不了那么多一直不断的连接了。所以当服务端出现大量 TIME_WAIT 时，系统资源被占满时，会导致处理不过来新的连接。</p>
<h2 id="HTTP-HTTPS"><a href="#HTTP-HTTPS" class="headerlink" title="HTTP/HTTPS"></a>HTTP/HTTPS</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h3 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h3><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI（统一资源标识符）用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。</p>
<h3 id="长连接-短连接"><a href="#长连接-短连接" class="headerlink" title="长连接/短连接"></a>长连接/短连接</h3><p>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。</p>
<p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。</p>
<img src="/posts/e255a10a/1612195694-ROTKiX-%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5.png" alt="长连接和短连接.png" style="zoom:48%;">

<h3 id="Session-Cookie-Token"><a href="#Session-Cookie-Token" class="headerlink" title="Session/Cookie/Token"></a>Session/Cookie/Token</h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。减少了服务器的 CPU 及内存资源的消耗。</p>
<p>基于表单认证的标准规范尚未有定论，一般会使用 Cookie 来管理Session（会话）。基于表单认证本身是通过服务器端的 Web 应用，将客户端发送过来的用户 ID 和密码与之前登录过的信息做匹配来进行认证的。但鉴于 HTTP 是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。即，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他与其他的用户。于是我们会使用 Cookie 来管理 Session，以弥补 HTTP 协议中不存在的状态管理功能。</p>
<p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。<br>服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>
<p><img src="/posts/e255a10a/%E5%9B%BE%E8%A7%A3HTTP-1621563317262.jpg" alt="图解HTTP"></p>
<p><strong>token</strong></p>
<p>Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌。当客户端第一次访问服务端，服务端会根据传过来的唯一标识userId，运用一些算法，并加上密钥，生成一个Token，然后通过BASE64编码一下之后将这个Token返回给客户端，客户端将Token保存起来（可以通过数据库或文件形式保存本地）。下次请求时，客户端只需要带上Token，服务器收到请求后，会用相同的算法和密钥去验证Token。</p>
<p><strong>cookie与session区别</strong></p>
<ul>
<li>存储位置与安全性：cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高；</li>
<li>存储空间：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，session无此限制</li>
<li>占用服务器资源：session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。</li>
</ul>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p><strong>缓存代理</strong><br>代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。</p>
<p><strong>透明代理</strong><br>转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。</p>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p><img src="/posts/e255a10a/image-20210521140933387.png" alt="image-20210521140933387"></p>
<h3 id="HTTP的不足"><a href="#HTTP的不足" class="headerlink" title="HTTP的不足"></a>HTTP的不足</h3><ul>
<li><p>通信使用明文（不加密），内容可能会被窃听</p>
<p><strong>通信的加密</strong></p>
<p>一种方式就是将通信加密。HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。</p>
<p><strong>内容的加密</strong></p>
<p>由于 HTTP 协议中没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把HTTP 报文里所含的内容进行加密处理。在这种情况下，客户端需要对 HTTP 报文进行加密处理后再发送请求。前提是要求客户端和服务器同时具备加密和解密机制。主要应用在 Web 服务中。有一点必须引起注意，由于该方式不同于 SSL 或 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险。</p>
</li>
<li><p>不验证通信方的身份，因此有可能遭遇伪装</p>
<p>虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL 则可以。SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。<br>证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图。另外，客户端持有证书即可完成个人身份的确认，也可用于对Web 网站的认证环节。</p>
</li>
<li><p>无法证明报文的完整性，所以有可能已遭篡改</p>
<p>请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack，MITM）。</p>
<p>虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。提供文件下载服务的 Web 网站也会提供相应的以 PGP（PrettyGood Privacy，完美隐私）创建的数字签名及 MD5 算法生成的散列值。用这些方法也依然无法百分百保证确认结果正确。因为 PGP 和 MD5 本身可以被改写。</p>
</li>
</ul>
<h3 id="HTTPS加密"><a href="#HTTPS加密" class="headerlink" title="HTTPS加密"></a>HTTPS加密</h3><p><strong>HTTPS 采用混合加密机制</strong></p>
<p>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。</p>
<p>所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。</p>
<p><strong>证明公开密钥正确性的证书</strong></p>
<p>首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。</p>
<p>接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。</p>
<p>此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。</p>
<p><img src="/posts/e255a10a/image-20210520185831982.png" alt="image-20210520185831982"></p>
<h3 id="HTTPS通信机制"><a href="#HTTPS通信机制" class="headerlink" title="HTTPS通信机制"></a>HTTPS通信机制</h3><img src="/posts/e255a10a/%E5%9B%BE%E8%A7%A3HTTP.jpg" alt="图解HTTP" style="zoom:80%;">

<ol>
<li>客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</li>
<li>服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li>
<li>服务器发送 Certificate 报文。报文中包含公开密钥证书。</li>
<li>最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</li>
<li>SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master  secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</li>
<li>接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</li>
<li>客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</li>
<li>服务器同样发送 Change Cipher Spec 报文。</li>
<li>服务器同样发送 Finished 报文。</li>
<li>服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</li>
<li>应用层协议通信，即发送 HTTP 响应。</li>
<li>最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP的通信。</li>
</ol>
<p><img src="/posts/e255a10a/%E5%9B%BE%E8%A7%A3HTTP-1621511420167.jpg" alt="图解HTTP"></p>
<h3 id="HTTPS的不足"><a href="#HTTPS的不足" class="headerlink" title="HTTPS的不足"></a>HTTPS的不足</h3><p>HTTPS 存在的问题是当使用 SSL 时，它的处理速度会变慢。SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源，导致处理速度变慢。和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和TCP 连接、发送 HTTP 请求 • 响应以外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag"># 基础知识</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/24d07237/" rel="prev" title="git和svn对比">
      <i class="fa fa-chevron-left"></i> git和svn对比
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/14ea6df7/" rel="next" title="数据库">
      数据库 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">1.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP"><span class="nav-number">1.1.</span> <span class="nav-text">TCP&#x2F;IP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%92%8CUDP%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.1.</span> <span class="nav-text">TCP和UDP区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">TCP如何保证传输的可靠性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">UDP如何实现可靠传输？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">1.1.4.</span> <span class="nav-text">三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E6%88%96%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">TCP 为什么是三次握手，而不是两次或四次？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0%E4%B8%80%EF%BC%9A%E9%81%BF%E5%85%8D%E5%8E%86%E5%8F%B2%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%B5%AA%E8%B4%B9%E8%B5%84%E6%BA%90"><span class="nav-number">1.1.4.1.1.</span> <span class="nav-text">原因一：避免历史连接，浪费资源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0%E4%BA%8C%EF%BC%9A%E5%90%8C%E6%AD%A5%E5%8F%8C%E6%96%B9%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="nav-number">1.1.4.1.2.</span> <span class="nav-text">原因二：同步双方初始序列号</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%A4%B1%E8%B4%A5%E4%BC%9A%E6%80%8E%E6%A0%B7%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">三次握手过程中如果最后一次握手失败会怎样处理？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.1.5.</span> <span class="nav-text">TCP 四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%A5%E6%89%8B%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">为什么挥手需要四次？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-TIME-WAIT-%E7%AD%89%E5%BE%85%E7%9A%84%E6%97%B6%E9%97%B4%E6%98%AF-2MSL%EF%BC%9F"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">为什么 TIME_WAIT 等待的时间是 2MSL？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-TIME-WAIT-%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">为什么需要 TIME_WAIT 状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TIME-WAIT-%E8%BF%87%E5%A4%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3%EF%BC%9F"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">TIME_WAIT 过多有什么危害？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-HTTPS"><span class="nav-number">1.2.</span> <span class="nav-text">HTTP&#x2F;HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URI-URL"><span class="nav-number">1.2.2.</span> <span class="nav-text">URI&#x2F;URL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5-%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.2.3.</span> <span class="nav-text">长连接&#x2F;短连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Session-Cookie-Token"><span class="nav-number">1.2.4.</span> <span class="nav-text">Session&#x2F;Cookie&#x2F;Token</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86"><span class="nav-number">1.2.5.</span> <span class="nav-text">代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">1.2.6.</span> <span class="nav-text">HTTP状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="nav-number">1.2.7.</span> <span class="nav-text">HTTP的不足</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS%E5%8A%A0%E5%AF%86"><span class="nav-number">1.2.8.</span> <span class="nav-text">HTTPS加密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.9.</span> <span class="nav-text">HTTPS通信机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="nav-number">1.2.10.</span> <span class="nav-text">HTTPS的不足</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tianyi Han"
      src="/upload/header.jpg">
  <p class="site-author-name" itemprop="name">Tianyi Han</p>
  <div class="site-description" itemprop="description">May the Force be with you</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tianyi Han</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.6' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  















  

  

</body>
</html>
